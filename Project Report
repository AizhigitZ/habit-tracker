1. Problem the Application Solves
In today’s fast-paced world, many people struggle to build and maintain positive habits while tracking their productivity effectively. Existing solutions are often fragmented: some apps focus only on habit tracking, others on statistics, but few provide a complete, developer-friendly backend that combines habit creation, daily progress logging, streak calculation, and meaningful productivity insights in one place.
The Personal Habit & Productivity Tracker Backend API solves this by providing a robust, RESTful backend service that allows users to:
•	Define custom habits with categories, descriptions, and reminders
•	Log daily progress (completed or not) with optional notes
•	Automatically calculate current streaks and completion rates over the last 30 days
•	Retrieve structured insights for better self-awareness and motivation
This backend serves as a solid foundation for any frontend (mobile, web, or desktop) habit-tracking application, enabling developers to build intuitive productivity tools quickly.

2. Chosen Technologies and Justification
Framework & Language
•	Spring Boot 3 with Java 21 Justification: Spring Boot is the industry-standard for building production-ready REST APIs in Java. It provides auto-configuration, embedded server, and excellent support for JPA, making development fast and scalable. Java 21 brings modern language features (records, pattern matching) while maintaining backward compatibility and strong ecosystem support.
Database
•	H2 in-memory database (with JPA/Hibernate) Justification: Perfect for development and demonstration purposes – no external setup required, fast startup, and automatic schema generation via spring.jpa.hibernate.ddl-auto=update. Easily replaceable with PostgreSQL/MySQL in production.
Key Libraries
•	Spring Data JPA – simplified repository layer and CRUD operations
•	Lombok – reduced boilerplate code (getters, setters, constructors)
•	Jackson – JSON serialization/deserialization
No external API keys were required, keeping the project simple to run and share.

3. Architecture Overview
The application follows clean, layered architecture with separation of concerns, making it maintainable, testable, and extensible.
Layers and Components
Presentation Layer (REST Controllers)
•	UserController – CRUD operations for users
•	HabitController – habit management tied to users
•	ProgressController – daily progress logging
•	InsightController – computed productivity statistics
Business/Service Layer
•	UserService, HabitService, ProgressService – core business logic
•	InsightService – calculates current streak and 30-day completion rate using stream operations and date logic
Data Access Layer (Repositories)
•	Spring Data JPA interfaces (JpaRepository) for User, Habit, and Progress
•	Custom query methods (e.g., findByUserId, findByHabitIdAndDate)
Entity/Model Layer
•	User, Habit, Progress – JPA entities with proper bidirectional relationships (@OneToMany, @ManyToOne)
•	InsightDto – lightweight DTO for returning computed insights
Key Design Patterns Applied
•	Repository Pattern (via Spring Data JPA)
•	Service Layer Pattern (separation of business logic)
•	Dependency Injection (Spring-managed beans)
Tech Stack Summary
•	Spring Boot 3.3.5 + Java 21
•	Spring Data JPA + H2 Database
•	Lombok for boilerplate reduction
•	Gradle (Groovy DSL) build tool

4. Main Technical Challenges and Solutions
Reserved Keyword Conflict in Database
•	Problem: Naming the entity User caused H2 to generate a table named user, which is a reserved SQL keyword → syntax error on insert.
•	Solution: Added @Table(name = "app_users") annotation on the User entity to use a safe table name.
Infinite Recursion in JSON Serialization
•	Problem: Bidirectional relationships (User ↔ Habit ↔ Progress) caused infinite nesting when returning JSON responses.
•	Solution: Applied @JsonIgnore on the parent side of relationships (user in Habit, habit in Progress) to break serialization cycles while preserving useful data flow.
Accurate Streak and Completion Rate Calculation
•	Problem: Streak logic must count consecutive completed days ending today, and completion rate must be based on the last 30 days.
•	Solution: Implemented sorting by date descending, iterating backward from today, and using Java streams for efficient counting in InsightService.
Daily Progress Update vs Insert
•	Problem: Users should update existing progress for a date rather than create duplicates.
•	Solution: Added custom repository method findByHabitIdAndDate to check for existing entries and update if found.
Clean and Testable API Design
•	Ensured all endpoints follow REST conventions with proper HTTP methods and nested resource paths (e.g., /api/users/{userId}/habits).
•	Used meaningful response codes and structured JSON output.

Conclusion
The Personal Habit & Productivity Tracker successfully delivers a fully functional, clean, and well-structured REST service that handles user management, habit tracking, progress logging, and intelligent productivity insights. It demonstrates strong application of OOP principles, design patterns, clean architecture, and modern Spring Boot practices — making it an excellent foundation for real-world productivity applications.
The project is easy to run, extend, and integrate with any frontend, proving that powerful habit-tracking systems can be built with clarity and maintainability in mind.
